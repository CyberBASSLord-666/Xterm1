# ============================================================================
# AI-Powered Code Review Workflow for PolliWall (Xterm1)
# ============================================================================
# This workflow provides intelligent code reviews using GitHub Copilot:
#
# FEATURES:
# - Comprehensive static analysis with ESLint and TypeScript
# - Code quality scoring based on lint errors, type errors, complexity
# - Automatic recommendations based on detected issues
# - GitHub Copilot integration via @copilot mentions for AI analysis
#
# All AI features are powered by GitHub Copilot. No external API keys required.
#
# Prerequisites:
# - None required! Works out of the box with static analysis
# - GitHub Copilot for PRs enabled for @copilot mentions
#
# Trigger: Pull request events
# ============================================================================

name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number
      review_depth:
        description: 'Review depth'
        required: false
        type: choice
        options:
          - standard
          - deep
          - security-focused
        default: 'standard'

# Security: Restrict permissions to minimum required for code review
permissions:
  contents: read
  pull-requests: write
  issues: write

# Security: Prevent concurrent runs on the same PR
concurrency:
  group: ai-review-${{ github.event.pull_request.number || inputs.pr_number }}
  cancel-in-progress: true

env:
  NODE_VERSION: '20'

jobs:
  # ============ AI CODE REVIEW ============
  ai-review:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR details
        id: pr_details
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request?.number || '${{ inputs.pr_number }}';
            
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: parseInt(prNumber)
            });
            
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: parseInt(prNumber),
              per_page: 100
            });
            
            // Get the diff for analysis
            const { data: diff } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: parseInt(prNumber),
              mediaType: {
                format: 'diff'
              }
            });
            
            // Categorize changed files
            const categories = {
              source: files.filter(f => f.filename.match(/\.(ts|tsx|js|jsx)$/) && !f.filename.includes('.spec.')),
              tests: files.filter(f => f.filename.includes('.spec.') || f.filename.includes('.test.')),
              styles: files.filter(f => f.filename.match(/\.(css|scss|less)$/)),
              config: files.filter(f => f.filename.match(/\.(json|yml|yaml)$|\.config\./)),
              docs: files.filter(f => f.filename.match(/\.(md|txt|rst)$/))
            };
            
            core.setOutput('pr_number', prNumber);
            core.setOutput('pr_title', pr.title);
            core.setOutput('pr_body', pr.body || '');
            core.setOutput('files_count', files.length);
            core.setOutput('source_files', categories.source.length);
            core.setOutput('additions', pr.additions);
            core.setOutput('deletions', pr.deletions);
            core.setOutput('has_source_changes', categories.source.length > 0);
            
            return {
              pr,
              files,
              categories,
              diff: typeof diff === 'string' ? diff : ''
            };

      - name: Setup Node.js
        if: steps.pr_details.outputs.has_source_changes == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        if: steps.pr_details.outputs.has_source_changes == 'true'
        run: npm ci

      - name: Run static analysis
        if: steps.pr_details.outputs.has_source_changes == 'true'
        id: static_analysis
        run: |
          echo "üîç Running static analysis..."
          
          # Run ESLint and capture issues
          set +e
          npx eslint "src/**/*.ts" --format json > eslint-report.json 2>&1
          ESLINT_EXIT=$?
          set -e
          
          LINT_ERRORS=$(cat eslint-report.json | jq '[.[] | .errorCount] | add // 0' 2>/dev/null || echo "0")
          LINT_WARNINGS=$(cat eslint-report.json | jq '[.[] | .warningCount] | add // 0' 2>/dev/null || echo "0")
          
          echo "lint_errors=$LINT_ERRORS" >> $GITHUB_OUTPUT
          echo "lint_warnings=$LINT_WARNINGS" >> $GITHUB_OUTPUT
          
          # Run TypeScript type checking
          set +e
          npx tsc --noEmit 2>&1 | head -50 > tsc-output.txt
          TSC_EXIT=$?
          set -e
          
          TYPE_ERRORS=$(grep -c "error TS" tsc-output.txt 2>/dev/null || echo "0")
          echo "type_errors=$TYPE_ERRORS" >> $GITHUB_OUTPUT
          
          # Detect code complexity
          npx eslint "src/**/*.ts" --rule '{"complexity": ["error", 10]}' --format json > complexity.json 2>&1 || true
          COMPLEX_FUNCTIONS=$(cat complexity.json | jq '[.[] | .messages[] | select(.ruleId == "complexity")] | length' 2>/dev/null || echo "0")
          echo "complex_functions=$COMPLEX_FUNCTIONS" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Generate AI Review Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const prNumber = parseInt('${{ steps.pr_details.outputs.pr_number }}');
            
            // Static analysis results
            const lintErrors = '${{ steps.static_analysis.outputs.lint_errors }}' || '0';
            const lintWarnings = '${{ steps.static_analysis.outputs.lint_warnings }}' || '0';
            const typeErrors = '${{ steps.static_analysis.outputs.type_errors }}' || '0';
            const complexFunctions = '${{ steps.static_analysis.outputs.complex_functions }}' || '0';
            
            // PR info
            const filesCount = '${{ steps.pr_details.outputs.files_count }}';
            const additions = '${{ steps.pr_details.outputs.additions }}';
            const deletions = '${{ steps.pr_details.outputs.deletions }}';
            const hasSourceChanges = '${{ steps.pr_details.outputs.has_source_changes }}' === 'true';
            
            // Check for existing AI review comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            const existingReview = comments.find(c => 
              c.user.login === 'github-actions[bot]' && 
              c.body.includes('AI Code Review')
            );
            
            // Build the review comment
            let reviewBody = `## ü§ñ AI Code Review

            ### üìä PR Statistics
            | Metric | Value |
            |--------|-------|
            | Files Changed | ${filesCount} |
            | Lines Added | +${additions} |
            | Lines Removed | -${deletions} |

            `;
            
            if (hasSourceChanges) {
              // Quality score calculation
              let qualityScore = 100;
              qualityScore -= Math.min(parseInt(lintErrors) * 5, 30);
              qualityScore -= Math.min(parseInt(typeErrors) * 5, 30);
              qualityScore -= Math.min(parseInt(complexFunctions) * 3, 15);
              qualityScore -= Math.min(parseInt(lintWarnings), 10);
              qualityScore = Math.max(0, qualityScore);
              
              const getScoreEmoji = (score) => {
                if (score >= 90) return 'üü¢';
                if (score >= 70) return 'üü°';
                if (score >= 50) return 'üü†';
                return 'üî¥';
              };
              
              reviewBody += `### üìà Code Quality Score: ${getScoreEmoji(qualityScore)} ${qualityScore}/100

            | Check | Count | Status |
            |-------|-------|--------|
            | Lint Errors | ${lintErrors} | ${parseInt(lintErrors) === 0 ? '‚úÖ' : '‚ùå'} |
            | Lint Warnings | ${lintWarnings} | ${parseInt(lintWarnings) < 5 ? '‚úÖ' : '‚ö†Ô∏è'} |
            | Type Errors | ${typeErrors} | ${parseInt(typeErrors) === 0 ? '‚úÖ' : '‚ùå'} |
            | Complex Functions | ${complexFunctions} | ${parseInt(complexFunctions) === 0 ? '‚úÖ' : '‚ö†Ô∏è'} |

            `;
              
              // Add recommendations based on issues found
              const recommendations = [];
              
              if (parseInt(lintErrors) > 0) {
                recommendations.push('üîß Run `@copilot fix lint` to auto-fix lint errors');
              }
              if (parseInt(typeErrors) > 0) {
                recommendations.push('üìù Fix TypeScript type errors before merging');
              }
              if (parseInt(complexFunctions) > 0) {
                recommendations.push('üîÑ Consider refactoring complex functions (cyclomatic complexity > 10)');
              }
              if (parseInt(lintWarnings) > 5) {
                recommendations.push('‚ö†Ô∏è Address lint warnings to improve code quality');
              }
              
              if (recommendations.length > 0) {
                reviewBody += `### üí° Recommendations

            ${recommendations.map(r => `- ${r}`).join('\n')}

            `;
              } else {
                reviewBody += `### ‚ú® Great Job!

            No major issues detected. The code looks good!

            `;
              }
            } else {
              reviewBody += `### ‚ÑπÔ∏è Non-Source Changes

            This PR only contains non-source file changes (documentation, configuration, etc.).
            No code quality analysis was performed.

            `;
            }
            
            reviewBody += `---
            
            *Powered by AI Code Review (GitHub Copilot) ‚Ä¢ [Request deeper analysis](${context.payload.pull_request?.html_url}#issuecomment-new) with \`@copilot\`*`;
            
            // Update or create comment
            if (existingReview) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingReview.id,
                body: reviewBody
              });
              console.log('Updated existing AI review comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: reviewBody
              });
              console.log('Created new AI review comment');
            }

      - name: Log Copilot Review Status
        if: github.event_name == 'pull_request' && github.event.action == 'opened'
        run: |
          echo "PR #${{ github.event.pull_request.number }} created - Copilot will automatically review if enabled on the repository"
