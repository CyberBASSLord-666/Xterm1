# ============================================================================
# Auto-Fix All Workflow for PolliWall (Xterm1)
# ============================================================================
# This workflow automatically runs on PRs and fixes:
# - ESLint issues (with --fix)
# - Prettier formatting issues
# - Security vulnerabilities (npm audit fix)
#
# All fixes are committed and pushed back to the PR branch automatically.
# This enables fully autonomous code quality and security maintenance.
#
# AUTONOMOUS MODE:
# - Tracks remaining issues after auto-fix
# - Escalates to manual intervention when issues cannot be fixed
# - Comments with specific guidance for unfixable issues
# ============================================================================

name: Auto-Fix All

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to fix (optional, uses current branch if not specified)'
        required: false
        type: number
      fix_types:
        description: 'Types of fixes to apply'
        required: false
        type: choice
        options:
          - all
          - lint-only
          - security-only
          - format-only
        default: 'all'

# Security: Restrict permissions to minimum required
permissions:
  contents: write
  pull-requests: write
  issues: write

# Security: Prevent concurrent runs on the same PR
concurrency:
  group: auto-fix-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

env:
  NODE_VERSION: '20'
  ESCALATION_LABEL: 'needs-manual-fix'
  AUTO_FIX_COMPLETE_LABEL: 'swarm-auto-fix-complete'

jobs:
  auto-fix-all:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    # ==========================================================================
    # SECURITY: Fork and Bot Exclusion Controls
    # ==========================================================================
    # These conditions prevent potentially dangerous scenarios:
    #
    # 1. Fork PRs are excluded because:
    #    - Forks don't have access to repository secrets
    #    - Committing to fork branches could fail or expose issues
    #    - Fork PR authors could potentially abuse auto-fix to inject code
    #
    # 2. Dependabot PRs are excluded because:
    #    - Dependabot manages its own updates
    #    - Auto-fix could conflict with dependabot's changes
    #    - Prevents potential update loops
    #
    # 3. Auto-fix commits are excluded to prevent infinite loops where
    #    an auto-fix triggers another auto-fix run
    # ==========================================================================
    if: |
      github.event.pull_request.head.repo.full_name == github.repository &&
      github.actor != 'dependabot[bot]'
    
    steps:
      - name: Check if auto-fix commit
        id: check_commit
        uses: actions/github-script@v7
        with:
          script: |
            // Check if the PR head commit is from a bot
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            if (commits.length > 0) {
              const lastCommit = commits[commits.length - 1];
              const isAutoFix = lastCommit.commit.message.includes('ðŸ¤–') || 
                               lastCommit.commit.message.includes('Auto-fix') ||
                               lastCommit.commit.message.includes('Auto-Fix');
              const isBot = lastCommit.author?.login === 'github-actions[bot]';
              
              core.setOutput('is_auto_fix', isAutoFix && isBot);
              console.log(`Last commit is auto-fix: ${isAutoFix && isBot}`);
            } else {
              core.setOutput('is_auto_fix', false);
            }

      - name: Skip if auto-fix commit
        if: steps.check_commit.outputs.is_auto_fix == 'true'
        run: |
          echo "â­ï¸ Skipping auto-fix workflow as the last commit was an auto-fix commit"
          echo "This prevents infinite loops in the autonomous fix system"

      - name: Checkout code
        if: steps.check_commit.outputs.is_auto_fix != 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          # Use GH_TOKEN to enable pushing commits and triggering other workflows
          # Falls back to GITHUB_TOKEN if GH_TOKEN is not configured
          token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        if: steps.check_commit.outputs.is_auto_fix != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        if: steps.check_commit.outputs.is_auto_fix != 'true'
        run: npm ci

      - name: Initialize fix tracking
        if: steps.check_commit.outputs.is_auto_fix != 'true'
        id: init
        run: |
          echo "LINT_FIXED=false" >> $GITHUB_ENV
          echo "FORMAT_FIXED=false" >> $GITHUB_ENV
          echo "SECURITY_FIXED=false" >> $GITHUB_ENV
          echo "LINT_REMAINING_ERRORS=0" >> $GITHUB_ENV
          echo "LINT_REMAINING_WARNINGS=0" >> $GITHUB_ENV

      # ============ LINT FIX ============
      - name: Run ESLint with auto-fix
        id: eslint
        if: steps.check_commit.outputs.is_auto_fix != 'true' && inputs.fix_types != 'security-only' && inputs.fix_types != 'format-only'
        run: |
          echo "ðŸ“ Running ESLint auto-fix..."
          
          # Capture the output and exit code
          set +e
          npx eslint "src/**/*.{ts,html}" --fix --max-warnings=0 2>&1 | tee eslint-output.txt
          ESLINT_EXIT=$?
          set -e
          
          # Count remaining issues after fix
          WARNINGS=$(grep -c "warning" eslint-output.txt || echo "0")
          ERRORS=$(grep -c "error" eslint-output.txt || echo "0")
          
          echo "eslint_warnings=$WARNINGS" >> $GITHUB_OUTPUT
          echo "eslint_errors=$ERRORS" >> $GITHUB_OUTPUT
          echo "eslint_exit=$ESLINT_EXIT" >> $GITHUB_OUTPUT
          echo "LINT_REMAINING_ERRORS=$ERRORS" >> $GITHUB_ENV
          echo "LINT_REMAINING_WARNINGS=$WARNINGS" >> $GITHUB_ENV
          
          # Check if files were changed
          if [[ -n $(git status --porcelain "src/**/*.ts" "src/**/*.html" 2>/dev/null) ]]; then
            echo "LINT_FIXED=true" >> $GITHUB_ENV
            echo "lint_changed=true" >> $GITHUB_OUTPUT
          else
            echo "lint_changed=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      # ============ FORMAT FIX ============
      - name: Run Prettier
        id: prettier
        if: steps.check_commit.outputs.is_auto_fix != 'true' && inputs.fix_types != 'security-only' && inputs.fix_types != 'lint-only'
        run: |
          echo "ðŸŽ¨ Running Prettier..."
          
          # Run prettier
          npx prettier --write "src/**/*.{ts,html,css,scss,json}" 2>&1 | tee prettier-output.txt || true
          
          # Check for additional config files
          npx prettier --write "*.json" "*.md" 2>&1 || true
          
          # Check if files were changed
          if [[ -n $(git status --porcelain) ]]; then
            echo "FORMAT_FIXED=true" >> $GITHUB_ENV
            echo "format_changed=true" >> $GITHUB_OUTPUT
          else
            echo "format_changed=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      # ============ SECURITY FIX ============
      - name: Run npm audit fix
        id: security
        if: steps.check_commit.outputs.is_auto_fix != 'true' && inputs.fix_types != 'lint-only' && inputs.fix_types != 'format-only'
        run: |
          echo "ðŸ”’ Running npm audit fix..."
          
          # Get current vulnerability count
          npm audit --json > audit-before.json 2>&1 || true
          VULNS_BEFORE=$(cat audit-before.json | jq '.metadata.vulnerabilities.total // 0')
          CRITICAL_BEFORE=$(cat audit-before.json | jq '.metadata.vulnerabilities.critical // 0')
          HIGH_BEFORE=$(cat audit-before.json | jq '.metadata.vulnerabilities.high // 0')
          
          echo "vulns_before=$VULNS_BEFORE" >> $GITHUB_OUTPUT
          echo "critical_before=$CRITICAL_BEFORE" >> $GITHUB_OUTPUT
          echo "high_before=$HIGH_BEFORE" >> $GITHUB_OUTPUT
          
          # Run npm audit fix
          npm audit fix 2>&1 | tee audit-fix-output.txt || true
          
          # Get new vulnerability count
          npm audit --json > audit-after.json 2>&1 || true
          VULNS_AFTER=$(cat audit-after.json | jq '.metadata.vulnerabilities.total // 0')
          CRITICAL_AFTER=$(cat audit-after.json | jq '.metadata.vulnerabilities.critical // 0')
          HIGH_AFTER=$(cat audit-after.json | jq '.metadata.vulnerabilities.high // 0')
          
          echo "vulns_after=$VULNS_AFTER" >> $GITHUB_OUTPUT
          echo "critical_after=$CRITICAL_AFTER" >> $GITHUB_OUTPUT
          echo "high_after=$HIGH_AFTER" >> $GITHUB_OUTPUT
          
          # Calculate fixed
          FIXED=$((VULNS_BEFORE - VULNS_AFTER))
          echo "vulns_fixed=$FIXED" >> $GITHUB_OUTPUT
          
          # Check if package files were changed
          if [[ -n $(git status --porcelain package.json package-lock.json 2>/dev/null) ]]; then
            echo "SECURITY_FIXED=true" >> $GITHUB_ENV
            echo "security_changed=true" >> $GITHUB_OUTPUT
          else
            echo "security_changed=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      # ============ COMMIT ALL FIXES ============
      - name: Check for any changes
        id: changes
        if: steps.check_commit.outputs.is_auto_fix != 'true'
        run: |
          if [[ -n $(git status --porcelain) ]]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            
            # Count changed files
            CHANGED_COUNT=$(git status --porcelain | wc -l)
            echo "changed_count=$CHANGED_COUNT" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "changed_count=0" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push all fixes
        if: steps.check_commit.outputs.is_auto_fix != 'true' && steps.changes.outputs.has_changes == 'true'
        id: commit
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          
          # Build commit message
          COMMIT_MSG="ðŸ¤– Auto-Fix: Applied comprehensive code quality fixes"
          COMMIT_BODY=""
          
          if [[ "$LINT_FIXED" == "true" ]]; then
            COMMIT_BODY="$COMMIT_BODY\n- âœ… ESLint: Auto-fixed lint issues"
          fi
          
          if [[ "$FORMAT_FIXED" == "true" ]]; then
            COMMIT_BODY="$COMMIT_BODY\n- âœ… Prettier: Code formatting standardized"
          fi
          
          if [[ "$SECURITY_FIXED" == "true" ]]; then
            VULNS_FIXED="${{ steps.security.outputs.vulns_fixed }}"
            COMMIT_BODY="$COMMIT_BODY\n- âœ… Security: Fixed $VULNS_FIXED vulnerabilities"
          fi
          
          COMMIT_BODY="$COMMIT_BODY\n\nThis commit was automatically generated by the Agentic Swarm Auto-Fix workflow."
          
          git commit -m "$COMMIT_MSG" -m "$(echo -e "$COMMIT_BODY")"
          git push
          
          echo "committed=true" >> $GITHUB_OUTPUT
          echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      # ============ REPORT RESULTS ============
      - name: Comment on PR with results
        if: always() && github.event_name == 'pull_request' && steps.check_commit.outputs.is_auto_fix != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const hasChanges = '${{ steps.changes.outputs.has_changes }}' === 'true';
            const committed = '${{ steps.commit.outputs.committed }}' === 'true';
            const sha = '${{ steps.commit.outputs.sha }}';
            const changedCount = '${{ steps.changes.outputs.changed_count }}';
            
            // Lint results
            const lintChanged = '${{ steps.eslint.outputs.lint_changed }}' === 'true';
            const eslintWarnings = '${{ steps.eslint.outputs.eslint_warnings }}' || '0';
            const eslintErrors = '${{ steps.eslint.outputs.eslint_errors }}' || '0';
            
            // Format results
            const formatChanged = '${{ steps.prettier.outputs.format_changed }}' === 'true';
            
            // Security results
            const securityChanged = '${{ steps.security.outputs.security_changed }}' === 'true';
            const vulnsBefore = '${{ steps.security.outputs.vulns_before }}' || '0';
            const vulnsAfter = '${{ steps.security.outputs.vulns_after }}' || '0';
            const vulnsFixed = '${{ steps.security.outputs.vulns_fixed }}' || '0';
            const criticalBefore = '${{ steps.security.outputs.critical_before }}' || '0';
            const criticalAfter = '${{ steps.security.outputs.critical_after }}' || '0';
            const highBefore = '${{ steps.security.outputs.high_before }}' || '0';
            const highAfter = '${{ steps.security.outputs.high_after }}' || '0';
            
            let body;
            
            if (committed) {
              body = `## ðŸ¤– Auto-Fix Applied

            The Agentic Swarm has automatically applied code quality fixes to this PR.

            ### Summary
            | Fix Type | Status | Details |
            |----------|--------|---------|
            | ðŸ“ ESLint | ${lintChanged ? 'âœ… Fixed' : 'âšª No issues'} | ${lintChanged ? 'Auto-fixed lint issues' : 'Code already clean'} |
            | ðŸŽ¨ Prettier | ${formatChanged ? 'âœ… Fixed' : 'âšª No issues'} | ${formatChanged ? 'Formatting standardized' : 'Already formatted'} |
            | ðŸ”’ Security | ${securityChanged ? 'âœ… Fixed' : (parseInt(vulnsBefore) > 0 ? 'âš ï¸ Manual review' : 'âšª No issues')} | ${securityChanged ? `Fixed ${vulnsFixed} vulnerabilities` : (parseInt(vulnsBefore) > 0 ? `${vulnsAfter} remaining` : 'No vulnerabilities')} |

            ### Changes
            - **Files changed:** ${changedCount}
            - **Commit:** \`${sha}\`

            ${parseInt(vulnsAfter) > 0 ? `### âš ï¸ Security Attention Required

            **${vulnsAfter}** vulnerabilities could not be auto-fixed:
            - ðŸ”´ Critical: ${criticalAfter}
            - ðŸŸ  High: ${highAfter}

            Consider running \`npm audit fix --force\` or manually updating packages.` : ''}

            ---
            *Generated by Agentic Swarm Auto-Fix*`;
            } else {
              body = `## âœ¨ Auto-Fix Check Complete

            No automatic fixes were needed - your code is already in great shape!

            ### Status
            | Check | Status |
            |-------|--------|
            | ðŸ“ ESLint | âœ… Clean |
            | ðŸŽ¨ Prettier | âœ… Formatted |
            | ðŸ”’ Security | ${parseInt(vulnsBefore) > 0 ? `âš ï¸ ${vulnsBefore} vulnerabilities (manual review needed)` : 'âœ… No vulnerabilities'} |

            ${parseInt(vulnsBefore) > 0 ? `### Security Note
            Found ${vulnsBefore} vulnerabilities that cannot be auto-fixed. Run \`npm audit\` for details.` : ''}

            ---
            *Generated by Agentic Swarm Auto-Fix*`;
            }
            
            // Check for existing auto-fix comment to update instead of creating new
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const existingComment = comments.find(c => 
              c.user.login === 'github-actions[bot]' && 
              (c.body.includes('Auto-Fix Applied') || c.body.includes('Auto-Fix Check Complete'))
            );
            
            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      # ============ ESCALATION FOR UNFIXABLE ISSUES ============
      - name: Check for remaining issues and escalate
        id: escalation
        if: always() && github.event_name == 'pull_request' && steps.check_commit.outputs.is_auto_fix != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            // Check for remaining issues after auto-fix
            const eslintErrors = parseInt('${{ steps.eslint.outputs.eslint_errors }}' || '0');
            const eslintWarnings = parseInt('${{ steps.eslint.outputs.eslint_warnings }}' || '0');
            const vulnsAfter = parseInt('${{ steps.security.outputs.vulns_after }}' || '0');
            const criticalAfter = parseInt('${{ steps.security.outputs.critical_after }}' || '0');
            const highAfter = parseInt('${{ steps.security.outputs.high_after }}' || '0');
            
            const hasRemainingLintIssues = eslintErrors > 0;
            const hasRemainingSecurityIssues = vulnsAfter > 0;
            const hasCriticalSecurity = criticalAfter > 0 || highAfter > 0;
            
            // Determine if escalation is needed
            const needsEscalation = hasRemainingLintIssues || hasRemainingSecurityIssues;
            
            core.setOutput('needs_escalation', needsEscalation);
            core.setOutput('has_lint_issues', hasRemainingLintIssues);
            core.setOutput('has_security_issues', hasRemainingSecurityIssues);
            core.setOutput('has_critical_security', hasCriticalSecurity);
            
            if (!needsEscalation) {
              console.log('âœ… No escalation needed - all issues were fixed automatically');
              return;
            }
            
            console.log('âš ï¸ Escalation needed - some issues could not be fixed automatically');
            
            // Build escalation message
            let escalationMessage = `## ðŸš¨ Manual Intervention Required

            The Agentic Swarm has completed its automated fixes, but some issues remain that require manual attention.

            ### Remaining Issues
            `;
            
            if (hasRemainingLintIssues) {
              escalationMessage += `
            #### ðŸ“ ESLint Issues (${eslintErrors} errors, ${eslintWarnings} warnings)

            These lint issues could not be auto-fixed and require manual code changes:

            **Suggested Actions:**
            1. Run \`npm run lint\` locally to see detailed error messages
            2. Common unfixable issues include:
               - Type errors that require code restructuring
               - Import/export issues
               - Complex refactoring requirements
            3. Consider using \`// eslint-disable-next-line\` for intentional violations (document why)

            `;
            }
            
            if (hasRemainingSecurityIssues) {
              escalationMessage += `
            #### ðŸ”’ Security Vulnerabilities (${vulnsAfter} remaining)
            ${hasCriticalSecurity ? '**âš ï¸ CRITICAL/HIGH severity issues detected!**' : ''}

            These vulnerabilities could not be auto-fixed with \`npm audit fix\`:

            **Suggested Actions:**
            1. Run \`npm audit\` locally to see detailed vulnerability information
            2. Try \`npm audit fix --force\` (may introduce breaking changes)
            3. Check if affected packages have newer major versions
            4. Consider replacing vulnerable packages with alternatives
            5. For dev dependencies, evaluate if the vulnerability affects production

            | Severity | Count |
            |----------|-------|
            | ðŸ”´ Critical | ${criticalAfter} |
            | ðŸŸ  High | ${highAfter} |

            `;
            }
            
            escalationMessage += `
            ---
            ### Next Steps

            1. **Review the issues above** and determine the appropriate fix strategy
            2. **Make manual changes** to address the remaining issues
            3. **Push your fixes** - the swarm will re-analyze and update status

            If you need assistance, consider:
            - \`@copilot help\` - Show available commands
            - \`@copilot check security\` - Re-run security scan after manual fixes

            ---
            *Escalation generated by Agentic Swarm Auto-Fix*`;
            
            // Post escalation comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: escalationMessage
            });
            
            console.log('ðŸ“ Posted escalation comment');

      - name: Add escalation label
        if: steps.escalation.outputs.needs_escalation == 'true' && steps.check_commit.outputs.is_auto_fix != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['${{ env.ESCALATION_LABEL }}']
              });
              console.log('Added escalation label');
            } catch (e) {
              console.log('Could not add escalation label:', e.message);
            }

      - name: Mark auto-fix complete
        if: always() && github.event_name == 'pull_request' && steps.check_commit.outputs.is_auto_fix != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['${{ env.AUTO_FIX_COMPLETE_LABEL }}']
              });
              console.log('Added auto-fix complete label');
            } catch (e) {
              console.log('Could not add label:', e.message);
            }

      # ============ SUMMARY ============
      - name: Generate job summary
        if: always() && steps.check_commit.outputs.is_auto_fix != 'true'
        run: |
          echo "## ðŸ¤– Auto-Fix All Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.commit.outputs.committed }}" == "true" ]]; then
            echo "âœ… **Fixes Applied and Committed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Fix Type | Applied |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|---------|" >> $GITHUB_STEP_SUMMARY
            echo "| ESLint | ${{ env.LINT_FIXED }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Prettier | ${{ env.FORMAT_FIXED }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Security | ${{ env.SECURITY_FIXED }} |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** \`${{ steps.commit.outputs.sha }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "âšª **No fixes needed** - Code is already clean!" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.security.outputs.vulns_after }}" != "0" ]] && [[ "${{ steps.security.outputs.vulns_after }}" != "" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### âš ï¸ Remaining Security Issues" >> $GITHUB_STEP_SUMMARY
            echo "- Total: ${{ steps.security.outputs.vulns_after }}" >> $GITHUB_STEP_SUMMARY
            echo "- Critical: ${{ steps.security.outputs.critical_after }}" >> $GITHUB_STEP_SUMMARY
            echo "- High: ${{ steps.security.outputs.high_after }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ steps.escalation.outputs.needs_escalation }}" == "true" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸš¨ Escalation Required" >> $GITHUB_STEP_SUMMARY
            echo "Some issues could not be fixed automatically and require manual intervention." >> $GITHUB_STEP_SUMMARY
          fi
