# ============================================================================
# Swarm Coordinator Workflow for PolliWall (Xterm1)
# ============================================================================
# This is the high-level orchestrator that coordinates multiple agents,
# analyzes context, and dispatches appropriate actions based on events.
#
# Features:
# - Coordinates multiple agent workflows
# - Analyzes PR/issue context to determine needed actions
# - Routes tasks to appropriate specialized agents
# - Provides unified reporting and status updates
# - Handles escalation for complex issues
# - AUTONOMOUS MODE: Automatically triggers @copilot fix commands when issues are detected
# ============================================================================

name: Swarm Coordinator

on:
  pull_request:
    types: [opened, synchronize, ready_for_review]
  pull_request_review:
    types: [submitted]
  issues:
    types: [opened, labeled]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - full-analysis
          - security-scan
          - performance-check
          - documentation-sync
          - release-prepare
      target_ref:
        description: 'Target branch or PR number'
        required: false
        type: string

# =============================================================================
# SECURITY: Permissions Configuration
# =============================================================================
# These permissions follow the principle of least privilege while enabling
# the necessary operations for the swarm coordinator.
#
# - contents:write - Required for committing auto-fixes
# - pull-requests:write - Required for PR comments and labels
# - issues:write - Required for issue management
# - actions:write - Required for triggering autonomous fix workflows
# - security-events:read - Required for reading security scan results
#
# IMPORTANT: The autonomous-fix-trigger job posts comments that can trigger
# the comment-command-processor workflow. This is an intentional design for
# autonomous self-healing, but relies on the security controls in that workflow.
# =============================================================================
permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write
  security-events: read

# Security: Prevent concurrent runs to avoid race conditions
concurrency:
  group: swarm-coordinator-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: false

# Environment variables for autonomous mode
env:
  AUTO_FIX_LABEL: 'swarm-auto-fix-attempted'
  AUTO_FIX_IN_PROGRESS_LABEL: 'swarm-auto-fix-in-progress'

jobs:
  # ============ CONTEXT ANALYSIS ============
  analyze-context:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      needs_lint: ${{ steps.analyze.outputs.needs_lint }}
      needs_tests: ${{ steps.analyze.outputs.needs_tests }}
      needs_security: ${{ steps.analyze.outputs.needs_security }}
      needs_docs: ${{ steps.analyze.outputs.needs_docs }}
      needs_performance: ${{ steps.analyze.outputs.needs_performance }}
      needs_a11y: ${{ steps.analyze.outputs.needs_a11y }}
      changed_files: ${{ steps.changes.outputs.files }}
      is_critical: ${{ steps.analyze.outputs.is_critical }}
      auto_fix_attempted: ${{ steps.check_labels.outputs.auto_fix_attempted }}
      is_auto_fix_commit: ${{ steps.check_commit.outputs.is_auto_fix }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if this is an auto-fix commit
        id: check_commit
        if: github.event_name == 'pull_request'
        run: |
          # Check if the last commit was made by the bot (auto-fix)
          LAST_COMMIT_AUTHOR=$(git log -1 --pretty=format:'%an')
          LAST_COMMIT_MSG=$(git log -1 --pretty=format:'%s')
          
          if [[ "$LAST_COMMIT_AUTHOR" == "github-actions[bot]" ]] && [[ "$LAST_COMMIT_MSG" =~ (Auto-fix|Auto-Fix|ðŸ¤–) ]]; then
            echo "is_auto_fix=true" >> $GITHUB_OUTPUT
            echo "ðŸ”„ Detected auto-fix commit, skipping autonomous triggers to prevent loops"
          else
            echo "is_auto_fix=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for auto-fix labels
        id: check_labels
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.pull_request.labels.map(l => l.name);
            const autoFixAttempted = labels.includes('${{ env.AUTO_FIX_LABEL }}');
            const autoFixInProgress = labels.includes('${{ env.AUTO_FIX_IN_PROGRESS_LABEL }}');
            
            core.setOutput('auto_fix_attempted', autoFixAttempted);
            core.setOutput('auto_fix_in_progress', autoFixInProgress);
            
            if (autoFixAttempted) {
              console.log('âš ï¸ Auto-fix was already attempted on this PR');
            }
            if (autoFixInProgress) {
              console.log('ðŸ”„ Auto-fix is currently in progress');
            }

      - name: Get changed files
        id: changes
        uses: actions/github-script@v7
        with:
          script: |
            if (context.eventName === 'pull_request') {
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number
              });
              
              const changedFiles = files.map(f => f.filename);
              core.setOutput('files', changedFiles.join(','));
              return changedFiles;
            }
            return [];

      - name: Analyze what's needed
        id: analyze
        run: |
          CHANGED="${{ steps.changes.outputs.files }}"
          
          # Check for TypeScript/code changes
          if echo "$CHANGED" | grep -qE '\.(ts|html)$'; then
            echo "needs_lint=true" >> $GITHUB_OUTPUT
            echo "needs_tests=true" >> $GITHUB_OUTPUT
          else
            echo "needs_lint=false" >> $GITHUB_OUTPUT
            echo "needs_tests=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for security-sensitive changes
          if echo "$CHANGED" | grep -qE '(security|auth|password|token|config|\.env)'; then
            echo "needs_security=true" >> $GITHUB_OUTPUT
            echo "is_critical=true" >> $GITHUB_OUTPUT
          else
            echo "needs_security=false" >> $GITHUB_OUTPUT
            echo "is_critical=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for documentation changes
          if echo "$CHANGED" | grep -qE '\.(md|txt)$'; then
            echo "needs_docs=true" >> $GITHUB_OUTPUT
          else
            echo "needs_docs=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for performance-impacting changes
          if echo "$CHANGED" | grep -qE '(component|service|pipe|directive)\.ts$'; then
            echo "needs_performance=true" >> $GITHUB_OUTPUT
          else
            echo "needs_performance=false" >> $GITHUB_OUTPUT
          fi
          
          # Check for UI/accessibility changes
          if echo "$CHANGED" | grep -qE '\.(html|css|scss)$'; then
            echo "needs_a11y=true" >> $GITHUB_OUTPUT
          else
            echo "needs_a11y=false" >> $GITHUB_OUTPUT
          fi

  # ============ LINT & FIX ============
  lint-fix:
    needs: analyze-context
    if: |
      needs.analyze-context.outputs.needs_lint == 'true' &&
      needs.analyze-context.outputs.is_auto_fix_commit != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      lint_status: ${{ steps.lint.outputs.status }}
      has_errors: ${{ steps.lint.outputs.has_errors }}
      has_warnings: ${{ steps.lint.outputs.has_warnings }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          # Use GH_TOKEN to enable pushing commits and triggering other workflows
          # Falls back to GITHUB_TOKEN if GH_TOKEN is not configured
          token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint with auto-fix
        id: lint
        run: |
          set +e
          npx eslint "src/**/*.{ts,html}" --fix 2>&1 | tee eslint-output.txt
          ESLINT_EXIT=$?
          set -e
          
          # Parse output for errors/warnings
          ERRORS=$(grep -c "error" eslint-output.txt || echo "0")
          WARNINGS=$(grep -c "warning" eslint-output.txt || echo "0")
          
          echo "has_errors=$([[ $ERRORS -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "has_warnings=$([[ $WARNINGS -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "error_count=$ERRORS" >> $GITHUB_OUTPUT
          echo "warning_count=$WARNINGS" >> $GITHUB_OUTPUT
          
          if [[ $ESLINT_EXIT -eq 0 ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi
          
          # Add step summary
          echo "## ðŸ“ Lint Results" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Errors | $ERRORS |" >> $GITHUB_STEP_SUMMARY
          echo "| Warnings | $WARNINGS |" >> $GITHUB_STEP_SUMMARY
          echo "| Exit Code | $ESLINT_EXIT |" >> $GITHUB_STEP_SUMMARY

      - name: Run Prettier
        run: npx prettier --write "src/**/*.{ts,html,css,scss,json}" || true

      - name: Check for changes
        id: changes
        run: |
          if [[ -n $(git status --porcelain) ]]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit fixes
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          git commit -m "ðŸ¤– Swarm: Auto-fix lint and formatting issues"
          git push

  # ============ RUN TESTS ============
  run-tests:
    needs: [analyze-context, lint-fix]
    if: |
      always() && 
      needs.analyze-context.outputs.needs_tests == 'true' &&
      needs.analyze-context.outputs.is_auto_fix_commit != 'true' &&
      (needs.lint-fix.result == 'success' || needs.lint-fix.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      test_status: ${{ steps.test.outputs.status }}
      tests_passed: ${{ steps.test.outputs.passed }}
      tests_failed: ${{ steps.test.outputs.failed }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        id: test
        run: |
          set +e
          npm test -- --coverage --watchAll=false 2>&1 | tee test-output.txt
          TEST_EXIT=$?
          set -e
          
          # Parse test output
          PASSED=$(grep -oP 'Tests:\s+\K\d+(?=\s+passed)' test-output.txt || echo "0")
          FAILED=$(grep -oP 'Tests:\s+\d+\s+failed' test-output.txt | grep -oP '\d+' | head -1 || echo "0")
          
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          
          if [[ $TEST_EXIT -eq 0 ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi
          
          # Add step summary
          echo "## ðŸ§ª Test Results" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
          echo "| Failed | $FAILED |" >> $GITHUB_STEP_SUMMARY
          echo "| Exit Code | $TEST_EXIT |" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Report test results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const testResult = '${{ steps.test.outputs.status }}';
            const status = testResult === 'success' ? 'âœ…' : 'âŒ';
            
            if (context.eventName === 'pull_request') {
              // Check if we already posted a test summary
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number
              });
              
              const existing = comments.find(c => 
                c.user.login === 'github-actions[bot]' && 
                c.body.includes('Swarm Test Results')
              );
              
              if (!existing) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `## ${status} Swarm Test Results

            | Check | Status |
            |-------|--------|
            | Unit Tests | ${status} ${testResult} |
            | Coverage | See artifacts |

            ---
            *Generated by Swarm Coordinator*`
                });
              }
            }

  # ============ SECURITY SCAN & AUTO-FIX ============
  security-scan:
    needs: analyze-context
    if: |
      (needs.analyze-context.outputs.needs_security == 'true' || needs.analyze-context.outputs.is_critical == 'true') &&
      needs.analyze-context.outputs.is_auto_fix_commit != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      vulnerability_count: ${{ steps.audit.outputs.vulnerabilities }}
      remaining_count: ${{ steps.security_fix.outputs.remaining }}
      fixed: ${{ steps.security_fix.outputs.fixed }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          # Use GH_TOKEN to enable pushing commits and triggering other workflows
          # Falls back to GITHUB_TOKEN if GH_TOKEN is not configured
          token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run npm audit
        id: audit
        run: |
          npm audit --json > audit-results.json 2>&1 || true
          VULNS=$(cat audit-results.json | jq '.metadata.vulnerabilities.total // 0')
          CRITICAL=$(cat audit-results.json | jq '.metadata.vulnerabilities.critical // 0')
          HIGH=$(cat audit-results.json | jq '.metadata.vulnerabilities.high // 0')
          FIXABLE=$(cat audit-results.json | jq '.metadata.vulnerabilities.total // 0')
          echo "vulnerabilities=$VULNS" >> $GITHUB_OUTPUT
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "fixable=$FIXABLE" >> $GITHUB_OUTPUT
          
          # Add step summary
          echo "## ðŸ”’ Security Audit Results" >> $GITHUB_STEP_SUMMARY
          echo "| Severity | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Critical | $CRITICAL |" >> $GITHUB_STEP_SUMMARY
          echo "| High | $HIGH |" >> $GITHUB_STEP_SUMMARY
          echo "| Total | $VULNS |" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Auto-fix security vulnerabilities
        id: security_fix
        if: steps.audit.outputs.vulnerabilities != '0'
        run: |
          echo "ðŸ”§ Attempting to auto-fix security vulnerabilities..."
          
          # Run npm audit fix (safe fixes only, no breaking changes)
          npm audit fix 2>&1 | tee audit-fix-output.txt || true
          
          # Check if any fixes were applied
          if [[ -n $(git status --porcelain package.json package-lock.json 2>/dev/null) ]]; then
            echo "fixed=true" >> $GITHUB_OUTPUT
            
            # Re-run audit to get new count
            npm audit --json > audit-after-fix.json 2>&1 || true
            REMAINING=$(cat audit-after-fix.json | jq '.metadata.vulnerabilities.total // 0')
            echo "remaining=$REMAINING" >> $GITHUB_OUTPUT
          else
            echo "fixed=false" >> $GITHUB_OUTPUT
            echo "remaining=${{ steps.audit.outputs.vulnerabilities }}" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Commit security fixes
        id: commit_security
        if: steps.security_fix.outputs.fixed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add package.json package-lock.json
          git commit -m "ðŸ”’ Security: Auto-fix npm audit vulnerabilities

          Applied npm audit fix to resolve security vulnerabilities.
          Original count: ${{ steps.audit.outputs.vulnerabilities }}
          Remaining: ${{ steps.security_fix.outputs.remaining }}
          
          This commit was automatically generated by the Swarm Security Guardian."
          git push
          echo "committed=true" >> $GITHUB_OUTPUT
          echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Report security findings
        uses: actions/github-script@v7
        with:
          script: |
            const vulns = '${{ steps.audit.outputs.vulnerabilities }}';
            const fixed = '${{ steps.security_fix.outputs.fixed }}' === 'true';
            const remaining = '${{ steps.security_fix.outputs.remaining }}' || vulns;
            const committed = '${{ steps.commit_security.outputs.committed }}' === 'true';
            const sha = '${{ steps.commit_security.outputs.sha }}';
            
            if (context.eventName === 'pull_request' && parseInt(vulns) > 0) {
              let message = `## ðŸ”’ Security Scan Results

            | Metric | Value |
            |--------|-------|
            | Original Vulnerabilities | ${vulns} |
            | Auto-Fixed | ${fixed ? 'âœ… Yes' : 'âŒ No fixable issues'} |
            | Remaining | ${remaining} |
            ${committed ? `| Commit | \`${sha}\` |` : ''}

            `;
              
              if (fixed && committed) {
                message += `### âœ… Security Fixes Applied

            The Swarm Security Guardian automatically fixed ${parseInt(vulns) - parseInt(remaining)} vulnerabilities using \`npm audit fix\`.

            `;
              }
              
              if (parseInt(remaining) > 0) {
                message += `### âš ï¸ Manual Review Required

            ${remaining} vulnerabilities remain that require manual review:
            1. Run \`npm audit\` locally to see details
            2. Consider \`npm audit fix --force\` for breaking changes
            3. Review and update packages manually if needed

            `;
              }
              
              message += `---
            *Generated by Swarm Security Guardian*`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: message
              });
            }

  # ============ STATUS SUMMARY ============
  swarm-summary:
    needs: [analyze-context, lint-fix, run-tests, security-scan]
    if: always() && needs.analyze-context.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      has_issues: ${{ steps.summary.outputs.has_issues }}
      issue_types: ${{ steps.summary.outputs.issue_types }}
    
    steps:
      - name: Generate swarm summary
        id: summary
        uses: actions/github-script@v7
        with:
          script: |
            if (context.eventName !== 'pull_request') return;
            
            const lintStatus = '${{ needs.lint-fix.result }}';
            const testStatus = '${{ needs.run-tests.result }}';
            const securityStatus = '${{ needs.security-scan.result }}';
            
            // Check for lint issues
            const lintHasErrors = '${{ needs.lint-fix.outputs.has_errors }}' === 'true';
            const lintHasWarnings = '${{ needs.lint-fix.outputs.has_warnings }}' === 'true';
            
            // Check for test failures
            const testsFailed = parseInt('${{ needs.run-tests.outputs.tests_failed }}' || '0') > 0;
            
            // Check for remaining security issues
            const securityRemaining = parseInt('${{ needs.security-scan.outputs.remaining_count }}' || '0') > 0;
            
            const getEmoji = (status) => {
              if (status === 'success') return 'âœ…';
              if (status === 'failure') return 'âŒ';
              if (status === 'skipped') return 'â­ï¸';
              return 'âšª';
            };
            
            // Determine if there are issues that need attention
            const hasIssues = lintStatus === 'failure' || testStatus === 'failure' || 
                              lintHasErrors || testsFailed || securityRemaining;
            
            // Track issue types
            const issueTypes = [];
            if (lintStatus === 'failure' || lintHasErrors) issueTypes.push('lint');
            if (testStatus === 'failure' || testsFailed) issueTypes.push('tests');
            if (securityRemaining) issueTypes.push('security');
            
            core.setOutput('has_issues', hasIssues);
            core.setOutput('issue_types', issueTypes.join(','));
            
            const summary = `## ðŸ¤– Swarm Coordinator Summary

            | Agent | Status | Result |
            |-------|--------|--------|
            | Code Quality | ${getEmoji(lintStatus)} | ${lintStatus} |
            | Test Automation | ${getEmoji(testStatus)} | ${testStatus} |
            | Security Guardian | ${getEmoji(securityStatus)} | ${securityStatus} |

            ${lintStatus === 'success' && testStatus === 'success' && securityStatus !== 'failure' 
              ? '### âœ… All checks passed! Ready for review.' 
              : '### âš ï¸ Some checks need attention.'}

            ---
            *Generated by the Agentic Swarm Coordinator*`;
            
            // Post summary
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: summary
            });

  # ============ AUTONOMOUS FIX TRIGGER ============
  # This job automatically triggers @copilot fix commands when issues are detected
  # to enable fully autonomous self-healing of the codebase
  autonomous-fix-trigger:
    needs: [analyze-context, lint-fix, run-tests, security-scan, swarm-summary]
    if: |
      always() &&
      github.event_name == 'pull_request' &&
      needs.swarm-summary.result == 'success' &&
      needs.swarm-summary.outputs.has_issues == 'true' &&
      needs.analyze-context.outputs.auto_fix_attempted != 'true' &&
      needs.analyze-context.outputs.is_auto_fix_commit != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Add auto-fix-in-progress label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: ['${{ env.AUTO_FIX_IN_PROGRESS_LABEL }}']
              });
            } catch (e) {
              console.log('Could not add label:', e.message);
            }

      - name: Determine fix command to trigger
        id: determine_command
        uses: actions/github-script@v7
        with:
          script: |
            const issueTypes = '${{ needs.swarm-summary.outputs.issue_types }}'.split(',').filter(Boolean);
            
            // Check lint status
            const lintFailed = '${{ needs.lint-fix.result }}' === 'failure';
            const lintHasErrors = '${{ needs.lint-fix.outputs.has_errors }}' === 'true';
            
            // Check test status
            const testsFailed = '${{ needs.run-tests.result }}' === 'failure';
            const testsHadFailures = parseInt('${{ needs.run-tests.outputs.tests_failed }}' || '0') > 0;
            
            // Check security status
            const securityRemaining = parseInt('${{ needs.security-scan.outputs.remaining_count }}' || '0') > 0;
            
            let command = '';
            let reason = '';
            
            // Determine the most appropriate fix command
            if (issueTypes.length > 1 || (lintFailed && securityRemaining)) {
              command = '@copilot fix all';
              reason = `Multiple issue types detected: ${issueTypes.join(', ')}`;
            } else if (lintFailed || lintHasErrors) {
              command = '@copilot fix lint';
              reason = 'Lint issues detected that could not be auto-fixed';
            } else if (securityRemaining) {
              command = '@copilot fix security';
              reason = `Security vulnerabilities remain (${parseInt('${{ needs.security-scan.outputs.remaining_count }}' || '0')} issues)`;
            }
            
            core.setOutput('command', command);
            core.setOutput('reason', reason);
            core.setOutput('should_trigger', command !== '');
            
            console.log(`Determined command: ${command}`);
            console.log(`Reason: ${reason}`);

      - name: Trigger autonomous fix command
        if: steps.determine_command.outputs.should_trigger == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const command = '${{ steps.determine_command.outputs.command }}';
            const reason = '${{ steps.determine_command.outputs.reason }}';
            
            const comment = `## ðŸ¤– Autonomous Swarm Action

            The Swarm Coordinator has detected issues that require attention.

            **Reason:** ${reason}

            **Triggering autonomous fix...**

            ${command}

            ---
            *This is an autonomous action by the Agentic Swarm. The system will attempt to fix the detected issues automatically.*
            *If fixes cannot be applied, manual intervention will be requested.*`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });
            
            console.log(`âœ… Posted autonomous fix trigger: ${command}`);

      - name: Mark auto-fix as attempted
        if: steps.determine_command.outputs.should_trigger == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            try {
              // Add the attempted label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: ['${{ env.AUTO_FIX_LABEL }}']
              });
              
              // Remove in-progress label
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  name: '${{ env.AUTO_FIX_IN_PROGRESS_LABEL }}'
                });
              } catch (e) {
                // Label might not exist
              }
            } catch (e) {
              console.log('Could not update labels:', e.message);
            }
