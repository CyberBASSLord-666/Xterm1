# ============================================================================
# Autonomous Improve Workflow for PolliWall (Xterm1)
# ============================================================================
# This workflow detects and applies code improvements:
# - Modernize old patterns to new patterns
# - Improve TypeScript strict mode opportunities
# - Add missing error handling
# - Add missing null checks
# - Suggest and apply better typing
# - Auto-add missing JSDoc comments to public functions
# - AI-powered code understanding for contextual improvements
#
# Trigger: Manual dispatch or via @copilot improve command
# ============================================================================

name: Autonomous Improve

on:
  workflow_dispatch:
    inputs:
      apply_fixes:
        description: 'Apply improvements automatically'
        required: false
        type: boolean
        default: true
      scope:
        description: 'Improvement scope'
        required: false
        type: choice
        options:
          - all
          - modernize
          - typing
          - error-handling
          - documentation
          - ai-suggestions
        default: 'all'
      ai_mode:
        description: 'Enable AI-powered improvements'
        required: false
        type: boolean
        default: true
      target_branch:
        description: 'Target branch (leave empty for current)'
        required: false
        type: string

  repository_dispatch:
    types: [improve-requested]

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  NODE_VERSION: '20'

jobs:
  # ============ ANALYZE IMPROVEMENT OPPORTUNITIES ============
  analyze:
    runs-on: ubuntu-latest
    outputs:
      modernize_opportunities: ${{ steps.modernize.outputs.count }}
      typing_issues: ${{ steps.typing.outputs.count }}
      error_handling_issues: ${{ steps.errors.outputs.count }}
      null_check_issues: ${{ steps.null_checks.outputs.count }}
      missing_jsdoc: ${{ steps.jsdoc.outputs.count }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch || github.ref }}
          token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Detect modernization opportunities
        id: modernize
        run: |
          echo "üîÑ Detecting modernization opportunities..."
          
          ISSUES=0
          
          # Check for var instead of let/const
          VAR_USAGE=$(grep -rn "^\s*var\s" src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          ISSUES=$((ISSUES + VAR_USAGE))
          
          # Check for callback patterns that could be promises
          CALLBACKS=$(grep -rn "function.*callback\|, function(" src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          
          # Check for old-style Angular patterns
          OLD_SUBSCRIBE=$(grep -rn "\.subscribe(" src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          
          # Check for non-async HTTP calls
          SYNC_HTTP=$(grep -rn "\.subscribe(.*=>" src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          
          echo "count=$ISSUES" >> $GITHUB_OUTPUT
          echo "var_usage=$VAR_USAGE" >> $GITHUB_OUTPUT
          echo "callbacks=$CALLBACKS" >> $GITHUB_OUTPUT
          echo "old_subscribe=$OLD_SUBSCRIBE" >> $GITHUB_OUTPUT
          
          echo "### Modernization Opportunities" >> $GITHUB_STEP_SUMMARY
          echo "| Pattern | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| 'var' instead of let/const | $VAR_USAGE |" >> $GITHUB_STEP_SUMMARY
          echo "| Callback patterns | $CALLBACKS |" >> $GITHUB_STEP_SUMMARY
          echo "| Observable subscribe() | $OLD_SUBSCRIBE |" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Detect typing issues
        id: typing
        run: |
          echo "üìù Detecting typing issues..."
          
          ISSUES=0
          
          # Check for 'any' type usage
          ANY_TYPES=$(grep -rn ": any\b" src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          ISSUES=$((ISSUES + ANY_TYPES))
          
          # Check for missing return types on functions
          # This is a simplified check - real implementation would use AST
          MISSING_RETURN=$(grep -rn "^export function\|^public \|^private \|^protected " src --include="*.ts" 2>/dev/null | grep -v "): \|): void\|): Promise\|): Observable" | wc -l || echo "0")
          
          # Check for implicit any
          IMPLICIT_ANY=$(grep -rn "noImplicitAny.*false" tsconfig.json 2>/dev/null | wc -l || echo "0")
          
          echo "count=$ISSUES" >> $GITHUB_OUTPUT
          echo "any_types=$ANY_TYPES" >> $GITHUB_OUTPUT
          echo "missing_return=$MISSING_RETURN" >> $GITHUB_OUTPUT
          
          echo "### Typing Issues" >> $GITHUB_STEP_SUMMARY
          echo "| Issue | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| 'any' type usage | $ANY_TYPES |" >> $GITHUB_STEP_SUMMARY
          echo "| Missing return types | $MISSING_RETURN |" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Detect missing error handling
        id: errors
        run: |
          echo "üõ°Ô∏è Detecting missing error handling..."
          
          ISSUES=0
          
          # Check for promises without catch
          UNCAUGHT_PROMISES=$(grep -rn "\.then(" src --include="*.ts" 2>/dev/null | grep -v "\.catch\|\.finally" | wc -l || echo "0")
          ISSUES=$((ISSUES + UNCAUGHT_PROMISES))
          
          # Check for async without try/catch
          UNSAFE_ASYNC=$(grep -rn "async\s" src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          TRY_CATCH=$(grep -rn "try\s*{" src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          
          # Check for fetch without error handling
          UNSAFE_FETCH=$(grep -rn "fetch(" src --include="*.ts" 2>/dev/null | grep -v "catch\|try" | wc -l || echo "0")
          ISSUES=$((ISSUES + UNSAFE_FETCH))
          
          echo "count=$ISSUES" >> $GITHUB_OUTPUT
          echo "uncaught_promises=$UNCAUGHT_PROMISES" >> $GITHUB_OUTPUT
          echo "unsafe_fetch=$UNSAFE_FETCH" >> $GITHUB_OUTPUT
          
          echo "### Error Handling" >> $GITHUB_STEP_SUMMARY
          echo "| Issue | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Promises without catch | $UNCAUGHT_PROMISES |" >> $GITHUB_STEP_SUMMARY
          echo "| Unsafe fetch calls | $UNSAFE_FETCH |" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Detect missing null checks
        id: null_checks
        run: |
          echo "üîç Detecting missing null checks..."
          
          ISSUES=0
          
          # Check for potential null dereference (simplified)
          OPTIONAL_CHAINS=$(grep -rn "\?\..*\?\..*\?\." src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          
          # Check for bang operators (!)
          BANG_OPERATORS=$(grep -rn "!\." src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          ISSUES=$((ISSUES + BANG_OPERATORS))
          
          # Check for potential null assignments
          NULL_ASSIGNS=$(grep -rn "= null\|= undefined" src --include="*.ts" 2>/dev/null | wc -l || echo "0")
          
          echo "count=$ISSUES" >> $GITHUB_OUTPUT
          echo "bang_operators=$BANG_OPERATORS" >> $GITHUB_OUTPUT
          echo "null_assigns=$NULL_ASSIGNS" >> $GITHUB_OUTPUT
          
          echo "### Null Safety" >> $GITHUB_STEP_SUMMARY
          echo "| Issue | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Bang operators (!) | $BANG_OPERATORS |" >> $GITHUB_STEP_SUMMARY
          echo "| Null/undefined assignments | $NULL_ASSIGNS |" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Detect missing JSDoc
        id: jsdoc
        run: |
          echo "üìö Detecting missing JSDoc comments..."
          
          ISSUES=0
          
          # Count exported functions without JSDoc
          # Check for export function without preceding /** comment
          for file in $(find src -name "*.ts" ! -name "*.spec.ts" ! -name "*.d.ts"); do
            EXPORTS=$(grep -n "^export\s\|^export default" "$file" 2>/dev/null | wc -l || echo "0")
            JSDOCS=$(grep -n "^\s*/\*\*" "$file" 2>/dev/null | wc -l || echo "0")
            DIFF=$((EXPORTS - JSDOCS))
            if [ "$DIFF" -gt 0 ]; then
              ISSUES=$((ISSUES + DIFF))
            fi
          done
          
          echo "count=$ISSUES" >> $GITHUB_OUTPUT
          
          echo "### Documentation" >> $GITHUB_STEP_SUMMARY
          echo "Missing JSDoc comments: ~$ISSUES exports" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

  # ============ APPLY IMPROVEMENTS ============
  improve:
    runs-on: ubuntu-latest
    needs: analyze
    if: inputs.apply_fixes != false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch || github.ref }}
          token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Replace var with let/const
        id: fix_var
        if: inputs.scope == 'all' || inputs.scope == 'modernize'
        run: |
          echo "üîÑ Replacing var with let/const..."
          
          FIXED=0
          
          for file in $(find src -name "*.ts" ! -name "*.spec.ts"); do
            if grep -q "^\s*var\s" "$file" 2>/dev/null; then
              # Replace var with let for reassigned variables, const for others
              # This is a simplified approach - prefer let for safety
              sed -i 's/^\(\s*\)var\s/\1let /g' "$file"
              FIXED=$((FIXED + 1))
            fi
          done
          
          echo "fixed=$FIXED" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Add missing type annotations
        id: fix_types
        if: inputs.scope == 'all' || inputs.scope == 'typing'
        run: |
          echo "üìù Running type checks..."
          
          # Run TypeScript compiler to find type issues
          set +e
          npx tsc --noEmit 2>&1 | tee tsc-output.txt
          set -e
          
          # ESLint can help with some type fixes
          npx eslint "src/**/*.ts" \
            --rule '{"@typescript-eslint/explicit-function-return-type": "warn"}' \
            --fix 2>&1 || true
        continue-on-error: true

      - name: Run ESLint auto-fix
        run: |
          echo "‚ú® Running ESLint auto-fix..."
          npx eslint "src/**/*.{ts,html}" --fix || true
        continue-on-error: true

      - name: Format code
        run: |
          echo "üé® Formatting code..."
          npx prettier --write "src/**/*.{ts,html,css,scss,json}" || true
        continue-on-error: true

      - name: AI-Powered Code Improvements
        id: ai_improve
        if: inputs.ai_mode == true && (inputs.scope == 'all' || inputs.scope == 'ai-suggestions')
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          echo "ü§ñ Running AI-powered code analysis..."
          
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "OpenAI API key not configured, skipping AI improvements"
            echo "ai_available=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "ai_available=true" >> $GITHUB_OUTPUT
          
          # Find files with potential improvements
          IMPROVEMENT_CANDIDATES=""
          
          # Files with 'any' types
          ANY_FILES=$(grep -rl ": any" src --include="*.ts" 2>/dev/null | head -3)
          if [ -n "$ANY_FILES" ]; then
            IMPROVEMENT_CANDIDATES="${IMPROVEMENT_CANDIDATES}\n\nFiles with 'any' types:\n${ANY_FILES}"
          fi
          
          # Files with complex functions
          npx eslint "src/**/*.ts" --rule '{"complexity": ["error", 10]}' --format json 2>/dev/null | \
            jq -r '.[] | select(.messages | length > 0) | .filePath' | head -3 > /tmp/complex-files.txt
          
          if [ -s /tmp/complex-files.txt ]; then
            COMPLEX_FILES=$(cat /tmp/complex-files.txt)
            IMPROVEMENT_CANDIDATES="${IMPROVEMENT_CANDIDATES}\n\nComplex files:\n${COMPLEX_FILES}"
          fi
          
          if [ -z "$IMPROVEMENT_CANDIDATES" ]; then
            echo "No improvement candidates found"
            exit 0
          fi
          
          # Get sample code for AI analysis
          for file in $ANY_FILES $(cat /tmp/complex-files.txt 2>/dev/null); do
            if [ -f "$file" ]; then
              echo -e "\n=== $file ===" >> /tmp/code-samples.txt
              head -80 "$file" >> /tmp/code-samples.txt
            fi
          done 2>/dev/null || true
          
          # Call OpenAI for suggestions
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d @- << 'APICALL'
          {
            "model": "gpt-4o-mini",
            "messages": [
              {"role": "system", "content": "You are a TypeScript expert. Analyze the code and provide specific, actionable improvements. Focus on: 1) Replacing 'any' with proper types, 2) Reducing complexity, 3) Improving error handling, 4) Better null safety. Format as markdown with code examples."},
              {"role": "user", "content": "$(cat /tmp/code-samples.txt 2>/dev/null | head -c 3000 | sed 's/"/\\"/g' | tr '\n' ' ')"}
            ],
            "max_tokens": 1500,
            "temperature": 0.3
          }
          APICALL
          )
          
          AI_SUGGESTIONS=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // "No suggestions available"')
          echo "$AI_SUGGESTIONS" > /tmp/ai-improvement-suggestions.md
          
          echo "## ü§ñ AI Improvement Suggestions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "$AI_SUGGESTIONS" >> $GITHUB_STEP_SUMMARY
        continue-on-error: true

      - name: Check for changes
        id: changes
        run: |
          if [[ -n $(git status --porcelain) ]]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            CHANGED_COUNT=$(git status --porcelain | wc -l)
            echo "changed_count=$CHANGED_COUNT" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "changed_count=0" >> $GITHUB_OUTPUT
          fi

      - name: Commit improvements
        if: steps.changes.outputs.has_changes == 'true'
        id: commit
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          
          git commit -m "üöÄ Improve: Applied automatic code improvements

          Changes applied:
          - Modernized old patterns (var ‚Üí let/const)
          - Applied ESLint auto-fixes
          - Improved code formatting
          - Enhanced type safety where possible

          Files changed: ${{ steps.changes.outputs.changed_count }}

          This commit was automatically generated by the Autonomous Improve workflow."
          
          git push
          echo "committed=true" >> $GITHUB_OUTPUT
          echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Generate improvement report
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const hasChanges = '${{ steps.changes.outputs.has_changes }}' === 'true';
            const committed = '${{ steps.commit.outputs.committed }}' === 'true';
            const sha = '${{ steps.commit.outputs.sha }}';
            const changedCount = '${{ steps.changes.outputs.changed_count }}';
            
            // Analysis results
            const modernizeOpp = '${{ needs.analyze.outputs.modernize_opportunities }}' || '0';
            const typingIssues = '${{ needs.analyze.outputs.typing_issues }}' || '0';
            const errorHandling = '${{ needs.analyze.outputs.error_handling_issues }}' || '0';
            const nullChecks = '${{ needs.analyze.outputs.null_check_issues }}' || '0';
            const missingJsdoc = '${{ needs.analyze.outputs.missing_jsdoc }}' || '0';
            
            let report = `## üöÄ Improvement Report
            
            ### Analysis Summary
            | Category | Opportunities Found |
            |----------|---------------------|
            | Modernization | ${modernizeOpp} |
            | Typing Issues | ${typingIssues} |
            | Error Handling | ${errorHandling} |
            | Null Safety | ${nullChecks} |
            | Missing JSDoc | ${missingJsdoc} |
            
            `;
            
            if (committed) {
              report += `### ‚úÖ Improvements Applied
            
            | Metric | Value |
            |--------|-------|
            | Files Changed | ${changedCount} |
            | Commit | \`${sha}\` |
            
            **Changes Applied:**
            - ‚úÖ Modernized old patterns
            - ‚úÖ Applied ESLint auto-fixes
            - ‚úÖ Improved code formatting
            - ‚úÖ Enhanced type safety
            `;
            } else if (hasChanges) {
              report += `### ‚ö†Ô∏è Changes Detected but Not Committed
            
            Changes were detected but could not be committed. Please review manually.
            `;
            } else {
              report += `### ‚ú® No Changes Needed
            
            The code is already well-structured!
            `;
            }
            
            report += `
            ### üí° Manual Review Recommended
            
            Some improvements require manual review:
            - Adding proper error handling with try/catch
            - Replacing 'any' types with specific types
            - Adding JSDoc comments to exported functions
            - Improving null safety with optional chaining
            
            ---
            *Generated by Autonomous Improve Workflow*`;
            
            // Write to job summary
            await core.summary
              .addRaw(report)
              .write();
