# ============================================================================
# Comment Command Processor for PolliWall (Xterm1)
# ============================================================================
# This workflow processes commands from PR/issue comments and executes
# appropriate actions. It's the interface for human-to-swarm communication.
#
# All commands work using static analysis tools and GitHub Copilot:
# - Uses static analysis tools (ESLint, TypeScript, npm audit)
# - Rule-based analysis and fixes
# - GitHub Copilot integration via @copilot mentions
#
# Supported Commands:
# - @copilot fix lint - Auto-fix lint issues
# - @copilot run tests - Run test suite
# - @copilot check security - Run security scan
# - @copilot apply suggestions - Apply review suggestions
# - @copilot summarize - Summarize PR changes
# - @copilot help - Show available commands
# - @copilot audit - Run full app audit
# - @copilot optimize - Find and apply optimizations
# - @copilot improve - Find and apply improvements
# - @copilot enhance - Apply QoL enhancements
# - @copilot full-auto - Run all autonomous workflows
# - @copilot analyze - Deep code analysis
# - @copilot ai-review - Code review
# ============================================================================

name: Comment Command Processor

on:
  issue_comment:
    types: [created]

# Security: Restrict permissions to minimum required
# Note: actions:write is needed only for workflow_dispatch triggers
permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

# Security: Prevent concurrent runs on the same PR to avoid race conditions
concurrency:
  group: comment-processor-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  process-command:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Security: Only process comments from repository collaborators
    # This prevents untrusted users from triggering workflow actions
    if: |
      contains(github.event.comment.body, '@copilot') &&
      (
        github.event.comment.author_association == 'OWNER' ||
        github.event.comment.author_association == 'MEMBER' ||
        github.event.comment.author_association == 'COLLABORATOR'
      )
    
    steps:
      - name: Parse command
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            // Security: Sanitize comment body to prevent injection
            const rawComment = context.payload.comment.body || '';
            // Remove potentially dangerous characters and limit length
            const comment = rawComment
              .toLowerCase()
              .replace(/[<>'"`;$\\]/g, '')
              .substring(0, 500);
            
            // Extract command after @copilot (handle multi-word and hyphenated commands)
            const match = comment.match(/@copilot\s+([\w-]+(?:\s+[\w-]+)?)/);
            if (!match) {
              core.setOutput('command', 'help');
              return;
            }
            
            const command = match[1].trim();
            core.setOutput('command', command);
            
            // Determine if this is a PR or issue
            const isPR = !!context.payload.issue.pull_request;
            core.setOutput('is_pr', isPR);
            
            return command;

      - name: Acknowledge command
        uses: actions/github-script@v7
        with:
          script: |
            const command = '${{ steps.parse.outputs.command }}';
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'eyes'
            });

      - name: Checkout code
        if: steps.parse.outputs.is_pr == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.issue.pull_request.head.ref || github.head_ref }}
          # Use GH_TOKEN to enable pushing commits and triggering other workflows
          token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        if: steps.parse.outputs.is_pr == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        if: steps.parse.outputs.is_pr == 'true'
        run: npm ci

      # ============ HELP COMMAND ============
      - name: Handle help command
        if: steps.parse.outputs.command == 'help'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ü§ñ Agentic Swarm Commands

            All commands work **out of the box** without any API keys!

            ### üîß Standard Commands
            | Command | Description |
            |---------|-------------|
            | \`@copilot help\` | Show this help message |
            | \`@copilot fix all\` | Fix everything: lint, security, formatting |
            | \`@copilot fix lint\` | Auto-fix ESLint and Prettier issues |
            | \`@copilot fix security\` | Auto-fix npm audit vulnerabilities |
            | \`@copilot run tests\` | Run the test suite |
            | \`@copilot check security\` | Run security vulnerability scan |
            | \`@copilot apply suggestions\` | Apply pending review suggestions |
            | \`@copilot summarize\` | Generate a summary of PR changes |
            | \`@copilot status\` | Show swarm status for this PR |
            
            ### üîÑ Refactoring Commands
            | Command | Description |
            |---------|-------------|
            | \`@copilot refactor\` | General code refactoring |
            | \`@copilot modernize\` | Modernize code patterns |
            | \`@copilot optimize\` | Performance optimization |
            | \`@copilot simplify\` | Reduce code complexity |
            | \`@copilot extract [type] [name] from [file]\` | Extract code to module |
            
            ### ü§ñ Autonomous Commands
            | Command | Description |
            |---------|-------------|
            | \`@copilot audit\` | Run full app audit (code quality, bundle, a11y, deps) |
            | \`@copilot optimize\` | Find and apply optimizations |
            | \`@copilot improve\` | Find and apply code improvements |
            | \`@copilot enhance\` | Apply QoL enhancements |
            | \`@copilot full-auto\` | Run all autonomous workflows in sequence |

            ### üß† Analysis Commands
            | Command | Description |
            |---------|-------------|
            | \`@copilot analyze\` | Deep code analysis |
            | \`@copilot ai-fix\` | Fix issues intelligently |
            | \`@copilot ai-refactor\` | Refactor code |
            | \`@copilot ai-review\` | Code review |
            | \`@copilot explain\` | Explain code or changes |

            **Usage:** Just comment with one of the commands above and I'll handle it!
            
            All AI features are powered by GitHub Copilot.

            ---
            *Agentic Swarm Command Processor*`
            });

      # ============ FIX LINT COMMAND ============
      - name: Handle fix lint command
        if: steps.parse.outputs.command == 'fix lint' && steps.parse.outputs.is_pr == 'true'
        id: fix_lint
        env:
          # Security: Pass username through environment variable
          REQUESTER: ${{ github.event.comment.user.login }}
        run: |
          npx eslint "src/**/*.{ts,html}" --fix || true
          npx prettier --write "src/**/*.{ts,html,css,scss,json}" || true
          
          if [[ -n $(git status --porcelain) ]]; then
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add -A
            # Security: Sanitize username for commit message
            SAFE_USER=$(echo "$REQUESTER" | tr -cd '[:alnum:]-_' | head -c 39)
            git commit -m "ü§ñ Fix: Applied lint and formatting corrections per @${SAFE_USER} request"
            git push
            echo "fixed=true" >> $GITHUB_OUTPUT
          else
            echo "fixed=false" >> $GITHUB_OUTPUT
          fi

      - name: Report lint fix results
        if: steps.parse.outputs.command == 'fix lint'
        uses: actions/github-script@v7
        with:
          script: |
            const fixed = '${{ steps.fix_lint.outputs.fixed }}' === 'true';
            const isPR = '${{ steps.parse.outputs.is_pr }}' === 'true';
            
            let message;
            if (!isPR) {
              message = '‚ö†Ô∏è This command only works on pull requests.';
            } else if (fixed) {
              message = '‚úÖ **Lint Fixed!** ESLint and Prettier corrections have been applied and committed.';
            } else {
              message = '‚ú® **No Changes Needed** - The code is already properly formatted.';
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });
            
            // Add success reaction
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: fixed ? 'rocket' : 'thumbs_up'
            });

      # ============ RUN TESTS COMMAND ============
      - name: Handle run tests command
        if: steps.parse.outputs.command == 'run tests' && steps.parse.outputs.is_pr == 'true'
        id: run_tests
        run: |
          npm test -- --coverage --watchAll=false > test-output.txt 2>&1 || true
          
          # Extract summary
          PASSED=$(grep -oP 'Tests:\s+\K\d+(?=\s+passed)' test-output.txt || echo "0")
          FAILED=$(grep -oP 'Tests:\s+\d+\s+failed,\s+\K\d+' test-output.txt || echo "0")
          
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          
          if [ "$FAILED" = "0" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

      - name: Report test results
        if: steps.parse.outputs.command == 'run tests'
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = '${{ steps.parse.outputs.is_pr }}' === 'true';
            
            if (!isPR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: '‚ö†Ô∏è This command only works on pull requests.'
              });
              return;
            }
            
            const passed = '${{ steps.run_tests.outputs.passed }}';
            const failed = '${{ steps.run_tests.outputs.failed }}';
            const status = '${{ steps.run_tests.outputs.status }}';
            
            const emoji = status === 'success' ? '‚úÖ' : '‚ùå';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ${emoji} Test Results

            | Metric | Value |
            |--------|-------|
            | Passed | ${passed} |
            | Failed | ${failed} |
            | Status | ${status} |

            ${status === 'failure' ? '‚ö†Ô∏è Some tests failed. Please review the test output.' : '‚ú® All tests passed!'}

            ---
            *Executed by Swarm Test Orchestrator*`
            });

      # ============ CHECK SECURITY COMMAND ============
      - name: Handle check security command
        if: steps.parse.outputs.command == 'check security' && steps.parse.outputs.is_pr == 'true'
        id: security
        run: |
          npm audit --json > audit.json 2>&1 || true
          
          CRITICAL=$(cat audit.json | jq '.metadata.vulnerabilities.critical // 0')
          HIGH=$(cat audit.json | jq '.metadata.vulnerabilities.high // 0')
          MODERATE=$(cat audit.json | jq '.metadata.vulnerabilities.moderate // 0')
          LOW=$(cat audit.json | jq '.metadata.vulnerabilities.low // 0')
          TOTAL=$(cat audit.json | jq '.metadata.vulnerabilities.total // 0')
          
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "moderate=$MODERATE" >> $GITHUB_OUTPUT
          echo "low=$LOW" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT

      - name: Report security results
        if: steps.parse.outputs.command == 'check security'
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = '${{ steps.parse.outputs.is_pr }}' === 'true';
            
            if (!isPR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: '‚ö†Ô∏è This command only works on pull requests.'
              });
              return;
            }
            
            const critical = '${{ steps.security.outputs.critical }}';
            const high = '${{ steps.security.outputs.high }}';
            const moderate = '${{ steps.security.outputs.moderate }}';
            const low = '${{ steps.security.outputs.low }}';
            const total = '${{ steps.security.outputs.total }}';
            
            const hasCritical = parseInt(critical) > 0 || parseInt(high) > 0;
            const emoji = total === '0' ? '‚úÖ' : (hasCritical ? 'üö®' : '‚ö†Ô∏è');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ${emoji} Security Scan Results

            | Severity | Count |
            |----------|-------|
            | üî¥ Critical | ${critical} |
            | üü† High | ${high} |
            | üü° Moderate | ${moderate} |
            | üü¢ Low | ${low} |
            | **Total** | **${total}** |

            ${total === '0' 
              ? '‚ú® No vulnerabilities found!' 
              : (hasCritical 
                ? 'üö® **Action Required:** Critical/high vulnerabilities detected. Run \`npm audit fix\` or review manually.'
                : '‚ö†Ô∏è Some vulnerabilities found. Consider running \`npm audit fix\`.'
              )
            }

            ---
            *Executed by Swarm Security Guardian*`
            });

      # ============ SUMMARIZE COMMAND ============
      - name: Handle summarize command
        if: steps.parse.outputs.command == 'summarize' && steps.parse.outputs.is_pr == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Categorize files
            const categories = {
              components: files.filter(f => f.filename.includes('.component.')),
              services: files.filter(f => f.filename.includes('.service.')),
              tests: files.filter(f => f.filename.includes('.spec.')),
              styles: files.filter(f => f.filename.match(/\.(css|scss)$/)),
              docs: files.filter(f => f.filename.match(/\.(md|txt)$/)),
              config: files.filter(f => f.filename.match(/\.(json|yml|yaml)$/)),
              other: []
            };
            
            // Calculate other
            const categorized = new Set([
              ...categories.components,
              ...categories.services,
              ...categories.tests,
              ...categories.styles,
              ...categories.docs,
              ...categories.config
            ].map(f => f.filename));
            
            categories.other = files.filter(f => !categorized.has(f.filename));
            
            const summary = `## üìã PR Summary

            **${pr.title}**

            ### Statistics
            | Metric | Value |
            |--------|-------|
            | Files Changed | ${files.length} |
            | Additions | +${pr.additions} |
            | Deletions | -${pr.deletions} |
            | Commits | ${pr.commits} |

            ### Files by Category
            | Category | Count | Files |
            |----------|-------|-------|
            | Components | ${categories.components.length} | ${categories.components.map(f => f.filename.split('/').pop()).join(', ') || '-'} |
            | Services | ${categories.services.length} | ${categories.services.map(f => f.filename.split('/').pop()).join(', ') || '-'} |
            | Tests | ${categories.tests.length} | ${categories.tests.map(f => f.filename.split('/').pop()).join(', ') || '-'} |
            | Styles | ${categories.styles.length} | ${categories.styles.map(f => f.filename.split('/').pop()).join(', ') || '-'} |
            | Documentation | ${categories.docs.length} | ${categories.docs.map(f => f.filename.split('/').pop()).join(', ') || '-'} |
            | Config | ${categories.config.length} | ${categories.config.map(f => f.filename.split('/').pop()).join(', ') || '-'} |
            | Other | ${categories.other.length} | ${categories.other.map(f => f.filename.split('/').pop()).join(', ') || '-'} |

            ---
            *Generated by Swarm Coordinator*`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: summary
            });

      # ============ STATUS COMMAND ============
      - name: Handle status command
        if: steps.parse.outputs.command == 'status'
        uses: actions/github-script@v7
        with:
          script: |
            const isPR = '${{ steps.parse.outputs.is_pr }}' === 'true';
            
            if (!isPR) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `## ü§ñ Swarm Status

            **Issue Mode** - Limited functionality available.

            For full swarm capabilities, use commands on pull requests.

            ---
            *Agentic Swarm Status*`
              });
              return;
            }
            
            // Get check runs for the PR
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });
            
            const checks = checkRuns.check_runs.map(c => ({
              name: c.name,
              status: c.status,
              conclusion: c.conclusion
            }));
            
            const getEmoji = (conclusion) => {
              if (conclusion === 'success') return '‚úÖ';
              if (conclusion === 'failure') return '‚ùå';
              if (conclusion === 'neutral') return '‚ö™';
              if (conclusion === 'skipped') return '‚è≠Ô∏è';
              return 'üîÑ';
            };
            
            const checksList = checks.map(c => 
              `| ${c.name} | ${getEmoji(c.conclusion)} | ${c.conclusion || c.status} |`
            ).join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ü§ñ Swarm Status

            ### CI/CD Checks
            | Check | Status | Result |
            |-------|--------|--------|
            ${checksList || '| No checks found | ‚ö™ | - |'}

            ### Available Actions
            - \`@copilot fix all\` - Fix everything (lint, security, formatting)
            - \`@copilot fix lint\` - Fix code style issues
            - \`@copilot fix security\` - Fix npm audit vulnerabilities
            - \`@copilot run tests\` - Run test suite
            - \`@copilot check security\` - Security scan
            - \`@copilot summarize\` - PR summary

            ---
            *Agentic Swarm Status*`
            });

      # ============ FIX ALL COMMAND ============
      - name: Handle fix all command
        if: steps.parse.outputs.command == 'fix all' && steps.parse.outputs.is_pr == 'true'
        id: fix_all
        env:
          # Security: Pass username through environment variable
          REQUESTER: ${{ github.event.comment.user.login }}
        run: |
          echo "üîß Starting comprehensive fix: lint, security, and formatting..."
          
          FIXES_APPLIED=""
          
          # 1. Fix ESLint issues
          echo "üìù Running ESLint auto-fix..."
          if npx eslint "src/**/*.{ts,html}" --fix 2>&1; then
            FIXES_APPLIED="$FIXES_APPLIED\n- ‚úÖ ESLint: Auto-fixed issues"
          else
            FIXES_APPLIED="$FIXES_APPLIED\n- ‚ö†Ô∏è ESLint: Some issues may require manual attention"
          fi
          
          # 2. Fix Prettier formatting
          echo "üé® Running Prettier..."
          if npx prettier --write "src/**/*.{ts,html,css,scss,json}" 2>&1; then
            FIXES_APPLIED="$FIXES_APPLIED\n- ‚úÖ Prettier: Code formatted"
          else
            FIXES_APPLIED="$FIXES_APPLIED\n- ‚ö†Ô∏è Prettier: Some formatting issues remain"
          fi
          
          # 3. Fix security vulnerabilities
          echo "üîí Running npm audit fix..."
          npm audit --json > audit-before.json 2>&1 || true
          VULNS_BEFORE=$(cat audit-before.json | jq '.metadata.vulnerabilities.total // 0')
          
          if npm audit fix 2>&1; then
            npm audit --json > audit-after.json 2>&1 || true
            VULNS_AFTER=$(cat audit-after.json | jq '.metadata.vulnerabilities.total // 0')
            
            if [[ "$VULNS_BEFORE" != "$VULNS_AFTER" ]]; then
              FIXED_COUNT=$((VULNS_BEFORE - VULNS_AFTER))
              FIXES_APPLIED="$FIXES_APPLIED\n- ‚úÖ Security: Fixed $FIXED_COUNT of $VULNS_BEFORE vulnerabilities"
            else
              FIXES_APPLIED="$FIXES_APPLIED\n- ‚ö™ Security: No auto-fixable vulnerabilities"
            fi
          else
            FIXES_APPLIED="$FIXES_APPLIED\n- ‚ö†Ô∏è Security: npm audit fix encountered issues"
          fi
          
          echo "vulns_before=$VULNS_BEFORE" >> $GITHUB_OUTPUT
          echo "vulns_after=$VULNS_AFTER" >> $GITHUB_OUTPUT
          
          # Check for changes and commit
          if [[ -n $(git status --porcelain) ]]; then
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add -A
            # Security: Sanitize username for commit message
            SAFE_USER=$(echo "$REQUESTER" | tr -cd '[:alnum:]-_' | head -c 39)
            git commit -m "ü§ñ Fix All: Applied comprehensive fixes per @${SAFE_USER} request

          Fixes applied:
          - ESLint auto-fix
          - Prettier formatting
          - npm audit fix (security)
          
          This commit was automatically generated by the Agentic Swarm."
            git push
            echo "fixed=true" >> $GITHUB_OUTPUT
          else
            echo "fixed=false" >> $GITHUB_OUTPUT
          fi
          
          echo -e "$FIXES_APPLIED" > fixes-applied.txt

      - name: Report fix all results
        if: steps.parse.outputs.command == 'fix all'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const fixed = '${{ steps.fix_all.outputs.fixed }}' === 'true';
            const isPR = '${{ steps.parse.outputs.is_pr }}' === 'true';
            const vulnsBefore = '${{ steps.fix_all.outputs.vulns_before }}' || '0';
            const vulnsAfter = '${{ steps.fix_all.outputs.vulns_after }}' || '0';
            
            let fixesApplied = '- See details above';
            if (fs.existsSync('fixes-applied.txt')) {
              fixesApplied = fs.readFileSync('fixes-applied.txt', 'utf8');
            }
            
            let message;
            if (!isPR) {
              message = '‚ö†Ô∏è This command only works on pull requests.';
            } else if (fixed) {
              message = `## ‚úÖ Fix All Complete

            The Agentic Swarm has applied comprehensive fixes to your PR.

            ### Fixes Applied
            ${fixesApplied}

            ### Security Summary
            | Metric | Value |
            |--------|-------|
            | Vulnerabilities Before | ${vulnsBefore} |
            | Vulnerabilities After | ${vulnsAfter} |
            | Fixed | ${parseInt(vulnsBefore) - parseInt(vulnsAfter)} |

            All changes have been committed and pushed.

            ---
            *Agentic Swarm - Fix All Complete*`;
            } else {
              message = `## ‚ú® No Changes Needed

            The code is already in great shape! No fixes were necessary.

            - ‚úÖ ESLint: No issues
            - ‚úÖ Prettier: Already formatted
            - ‚úÖ Security: ${vulnsBefore === '0' ? 'No vulnerabilities' : `${vulnsBefore} vulnerabilities (none auto-fixable)`}

            ---
            *Agentic Swarm - Fix All Complete*`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: fixed ? 'rocket' : 'thumbs_up'
            });

      # ============ FIX SECURITY COMMAND ============
      - name: Handle fix security command
        if: steps.parse.outputs.command == 'fix security' && steps.parse.outputs.is_pr == 'true'
        id: fix_security
        env:
          # Security: Pass username through environment variable
          REQUESTER: ${{ github.event.comment.user.login }}
        run: |
          echo "üîí Starting security vulnerability auto-fix..."
          
          # Get current vulnerability count
          npm audit --json > audit-before.json 2>&1 || true
          VULNS_BEFORE=$(cat audit-before.json | jq '.metadata.vulnerabilities.total // 0')
          CRITICAL_BEFORE=$(cat audit-before.json | jq '.metadata.vulnerabilities.critical // 0')
          HIGH_BEFORE=$(cat audit-before.json | jq '.metadata.vulnerabilities.high // 0')
          
          echo "vulns_before=$VULNS_BEFORE" >> $GITHUB_OUTPUT
          echo "critical_before=$CRITICAL_BEFORE" >> $GITHUB_OUTPUT
          echo "high_before=$HIGH_BEFORE" >> $GITHUB_OUTPUT
          
          # Attempt auto-fix
          npm audit fix 2>&1 | tee audit-fix-output.txt || true
          
          # Get new vulnerability count
          npm audit --json > audit-after.json 2>&1 || true
          VULNS_AFTER=$(cat audit-after.json | jq '.metadata.vulnerabilities.total // 0')
          CRITICAL_AFTER=$(cat audit-after.json | jq '.metadata.vulnerabilities.critical // 0')
          HIGH_AFTER=$(cat audit-after.json | jq '.metadata.vulnerabilities.high // 0')
          
          echo "vulns_after=$VULNS_AFTER" >> $GITHUB_OUTPUT
          echo "critical_after=$CRITICAL_AFTER" >> $GITHUB_OUTPUT
          echo "high_after=$HIGH_AFTER" >> $GITHUB_OUTPUT
          
          # Check for changes
          if [[ -n $(git status --porcelain package.json package-lock.json 2>/dev/null) ]]; then
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add package.json package-lock.json
            # Security: Sanitize username for commit message
            SAFE_USER=$(echo "$REQUESTER" | tr -cd '[:alnum:]-_' | head -c 39)
            git commit -m "üîí Security: Auto-fix vulnerabilities per @${SAFE_USER} request

          Before: $VULNS_BEFORE vulnerabilities ($CRITICAL_BEFORE critical, $HIGH_BEFORE high)
          After: $VULNS_AFTER vulnerabilities ($CRITICAL_AFTER critical, $HIGH_AFTER high)
          
          This commit was automatically generated by the Swarm Security Guardian."
            git push
            echo "fixed=true" >> $GITHUB_OUTPUT
          else
            echo "fixed=false" >> $GITHUB_OUTPUT
          fi

      - name: Report fix security results
        if: steps.parse.outputs.command == 'fix security'
        uses: actions/github-script@v7
        with:
          script: |
            const fixed = '${{ steps.fix_security.outputs.fixed }}' === 'true';
            const isPR = '${{ steps.parse.outputs.is_pr }}' === 'true';
            const vulnsBefore = '${{ steps.fix_security.outputs.vulns_before }}' || '0';
            const vulnsAfter = '${{ steps.fix_security.outputs.vulns_after }}' || '0';
            const criticalBefore = '${{ steps.fix_security.outputs.critical_before }}' || '0';
            const criticalAfter = '${{ steps.fix_security.outputs.critical_after }}' || '0';
            const highBefore = '${{ steps.fix_security.outputs.high_before }}' || '0';
            const highAfter = '${{ steps.fix_security.outputs.high_after }}' || '0';
            
            let message;
            if (!isPR) {
              message = '‚ö†Ô∏è This command only works on pull requests.';
            } else if (fixed) {
              const fixedCount = parseInt(vulnsBefore) - parseInt(vulnsAfter);
              message = `## üîí Security Fix Complete

            The Swarm Security Guardian has automatically fixed vulnerabilities.

            ### Summary
            | Severity | Before | After | Fixed |
            |----------|--------|-------|-------|
            | üî¥ Critical | ${criticalBefore} | ${criticalAfter} | ${parseInt(criticalBefore) - parseInt(criticalAfter)} |
            | üü† High | ${highBefore} | ${highAfter} | ${parseInt(highBefore) - parseInt(highAfter)} |
            | **Total** | **${vulnsBefore}** | **${vulnsAfter}** | **${fixedCount}** |

            ${parseInt(vulnsAfter) > 0 ? `### ‚ö†Ô∏è Remaining Vulnerabilities

            ${vulnsAfter} vulnerabilities could not be auto-fixed. Consider:
            1. \`npm audit fix --force\` for breaking changes
            2. Manual dependency updates
            3. Finding alternative packages` : '### ‚úÖ All Vulnerabilities Resolved!'}

            ---
            *Swarm Security Guardian - Fix Complete*`;
            } else if (vulnsBefore === '0') {
              message = `## ‚úÖ No Vulnerabilities

            No security vulnerabilities were found in your dependencies!

            ---
            *Swarm Security Guardian*`;
            } else {
              message = `## ‚ö†Ô∏è No Auto-Fixable Vulnerabilities

            Found **${vulnsBefore}** vulnerabilities but none could be automatically fixed.

            | Severity | Count |
            |----------|-------|
            | üî¥ Critical | ${criticalBefore} |
            | üü† High | ${highBefore} |

            ### Recommended Actions
            1. Run \`npm audit fix --force\` locally (may include breaking changes)
            2. Manually update vulnerable packages
            3. Check for alternative packages

            ---
            *Swarm Security Guardian*`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: fixed ? 'rocket' : (vulnsBefore === '0' ? 'heart' : 'thumbs_up')
            });

      # ============ AUDIT COMMAND ============
      - name: Handle audit command
        if: steps.parse.outputs.command == 'audit'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## üìä Starting Full App Audit

            The Agentic Swarm is now running a comprehensive audit including:

            - üìù Code quality analysis (lint, complexity, duplication)
            - üì¶ Bundle size analysis
            - ‚ôø Accessibility audit
            - ‚ö° Performance audit
            - üîí Dependency health check

            This may take several minutes. Results will be posted when complete.

            ---
            *Autonomous Audit Initiated*`
            });
            
            // Trigger the audit workflow
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'autonomous-audit.yml',
              ref: 'main',
              inputs: {
                scope: 'full',
                create_issue: 'true'
              }
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

      # ============ IMPROVE COMMAND ============
      - name: Handle improve command
        if: steps.parse.outputs.command == 'improve' && steps.parse.outputs.is_pr == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `## üöÄ Starting Code Improvement Analysis

            The Agentic Swarm is analyzing your code for improvement opportunities:

            - üîÑ Old patterns that can be modernized
            - üìù Missing TypeScript strict mode opportunities
            - üõ°Ô∏è Missing error handling
            - ‚ùì Missing null checks
            - üìö Missing JSDoc comments

            Improvements will be applied automatically where safe.

            ---
            *Autonomous Improve Initiated*`
            });
            
            // Trigger the improve workflow
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'autonomous-improve.yml',
              ref: pr.head.ref,
              inputs: {
                apply_fixes: 'true',
                scope: 'all',
                target_branch: pr.head.ref
              }
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

      # ============ ENHANCE COMMAND ============
      - name: Handle enhance command
        if: steps.parse.outputs.command == 'enhance' && steps.parse.outputs.is_pr == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `## ‚ú® Starting QoL Enhancements

            The Agentic Swarm is applying quality of life improvements:

            - üì¶ Organizing and sorting imports
            - üìÑ Adding/fixing file headers
            - üè∑Ô∏è Standardizing naming conventions
            - üì¶ Adding missing barrel exports
            - üßπ Cleaning up console.log statements
            - üìù Standardizing error messages

            Enhancements will be committed automatically.

            ---
            *Autonomous QoL Enhancement Initiated*`
            });
            
            // Trigger the QoL workflow
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'autonomous-qol.yml',
              ref: pr.head.ref,
              inputs: {
                apply_fixes: 'true',
                scope: 'all',
                target_branch: pr.head.ref
              }
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

      # ============ FULL-AUTO COMMAND ============
      - name: Handle full-auto command
        if: steps.parse.outputs.command == 'full-auto' && steps.parse.outputs.is_pr == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `## ü§ñ Full Autonomous Mode Activated

            The Agentic Swarm is running ALL autonomous workflows:

            ### Workflow Sequence
            1. üìä **Audit** - Comprehensive code analysis
            2. ‚ö° **Optimize** - Remove unused code, improve performance
            3. üöÄ **Improve** - Modernize patterns, add types
            4. ‚ú® **Enhance** - QoL improvements
            5. üîß **Fix All** - Final lint, format, security fixes

            This is a comprehensive operation and may take several minutes.
            Each workflow will report its results when complete.

            ---
            *Full Autonomous Mode Initiated*`
            });
            
            // Trigger workflows in sequence (they will run in order due to branch state)
            
            // 1. First run optimize
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'autonomous-optimize.yml',
              ref: pr.head.ref,
              inputs: {
                apply_fixes: 'true',
                scope: 'all',
                target_branch: pr.head.ref
              }
            });
            
            // Small delay to avoid race conditions
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // 2. Run improve
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'autonomous-improve.yml',
              ref: pr.head.ref,
              inputs: {
                apply_fixes: 'true',
                scope: 'all',
                target_branch: pr.head.ref
              }
            });
            
            // Small delay
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // 3. Run QoL enhancements
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'autonomous-qol.yml',
              ref: pr.head.ref,
              inputs: {
                apply_fixes: 'true',
                scope: 'all',
                target_branch: pr.head.ref
              }
            });
            
            // 4. Also run audit in the background
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'autonomous-audit.yml',
              ref: 'main',
              inputs: {
                scope: 'full',
                create_issue: 'false'
              }
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });
            
            // Post follow-up
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `### ‚úÖ All Workflows Triggered

            The following workflows have been initiated:

            | Workflow | Status |
            |----------|--------|
            | autonomous-optimize | üöÄ Triggered |
            | autonomous-improve | üöÄ Triggered |
            | autonomous-qol | üöÄ Triggered |
            | autonomous-audit | üöÄ Triggered |

            Check the [Actions tab](https://github.com/${context.repo.owner}/${context.repo.repo}/actions) for progress.

            ---
            *Agentic Swarm - Full Auto Mode*`
            });

      # ============ AI ANALYZE COMMAND ============
      - name: Handle analyze command
        if: steps.parse.outputs.command == 'analyze'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const isPR = '${{ steps.parse.outputs.is_pr }}' === 'true';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `## üß† Code Analysis Initiated

            The AI Agent is performing a comprehensive analysis of ${isPR ? 'this PR' : 'the codebase'}:

            ### Analysis Features
            - üìä Code quality metrics (ESLint, TypeScript)
            - üîí Security assessment (npm audit)
            - ‚ö° Complexity analysis
            - üìù Code pattern detection
            - ü§ñ GitHub Copilot integration for AI insights

            ${isPR ? '' : '> **Note:** For PR-specific analysis, trigger this command from a pull request.'}

            Analysis results will be posted when complete.

            ---
            *AI Autonomous Agent - Analysis Mode (GitHub Copilot)*`
            });
            
            // Trigger the AI agent workflow
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ai-autonomous-agent.yml',
              ref: 'main',
              inputs: {
                mode: 'analyze',
                focus_areas: 'code-quality,security,performance,architecture'
              }
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

      # ============ AI FIX COMMAND ============
      - name: Handle ai-fix command
        if: steps.parse.outputs.command == 'ai-fix' && steps.parse.outputs.is_pr == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `## ü§ñ Intelligent Fix Mode Activated

            The AI Agent is analyzing and fixing issues:

            ### Fixes Applied
            - üîß ESLint auto-fix
            - üé® Prettier formatting
            - üîí npm audit security fixes
            - ü§ñ GitHub Copilot integration for AI insights

            Fixes will be committed to this branch when complete.

            ---
            *AI Fix Agent (GitHub Copilot)*`
            });
            
            // Trigger the AI fix workflow
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ai-fix-issues.yml',
              ref: pr.head.ref,
              inputs: {
                issue_type: 'all',
                target_branch: pr.head.ref,
                ai_mode: 'true',
                create_pr: 'false'
              }
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

      # ============ AI REFACTOR COMMAND ============
      - name: Handle ai-refactor command
        if: steps.parse.outputs.command == 'ai-refactor' && steps.parse.outputs.is_pr == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `## üîÑ Refactor Mode Activated

            The agent is analyzing code for refactoring opportunities:

            ### Refactoring Features
            - üìä Complexity analysis
            - üîç Anti-pattern detection
            - üõ†Ô∏è ESLint rule-based improvements
            - üé® Code formatting
            - ü§ñ GitHub Copilot integration for AI insights

            Changes will be applied when analysis is complete.

            ---
            *Refactor Agent (GitHub Copilot)*`
            });
            
            // Trigger the improve workflow
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'autonomous-improve.yml',
              ref: pr.head.ref,
              inputs: {
                apply_fixes: 'true',
                scope: 'all',
                target_branch: pr.head.ref
              }
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

      # ============ AI REVIEW COMMAND ============
      - name: Handle ai-review command
        if: steps.parse.outputs.command == 'ai-review' && steps.parse.outputs.is_pr == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `## üîç Code Review Requested

            Performing a comprehensive code review:

            ### Review Features
            - üìù Static analysis (ESLint, TypeScript)
            - üîí Security vulnerability check
            - ‚ö° Complexity analysis
            - üìä Code quality scoring
            - ü§ñ GitHub Copilot integration for AI insights

            Review comments will be posted when complete.

            ---
            *Code Review Agent (GitHub Copilot)*`
            });
            
            // Trigger the AI code review workflow
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ai-code-review.yml',
              ref: 'main',
              inputs: {
                pr_number: String(prNumber),
                review_depth: 'deep'
              }
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });

      # ============ EXPLAIN COMMAND ============
      - name: Handle explain command
        if: steps.parse.outputs.command == 'explain' && steps.parse.outputs.is_pr == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            
            // Get PR files for explanation
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 20
            });
            
            // Categorize files
            const categories = {
              components: files.filter(f => f.filename.includes('.component.')),
              services: files.filter(f => f.filename.includes('.service.')),
              tests: files.filter(f => f.filename.includes('.spec.') || f.filename.includes('.test.')),
              styles: files.filter(f => f.filename.match(/\.(css|scss)$/)),
              docs: files.filter(f => f.filename.match(/\.(md|txt)$/)),
              config: files.filter(f => f.filename.match(/\.(json|yml|yaml)$/)),
            };
            
            // Build a summary of changes
            const filesSummary = files.slice(0, 15).map(f => 
              `- \`${f.filename}\` (+${f.additions}/-${f.deletions})`
            ).join('\n');
            
            const categoryBreakdown = Object.entries(categories)
              .filter(([_, files]) => files.length > 0)
              .map(([cat, files]) => `- **${cat}**: ${files.length} file(s)`)
              .join('\n');
            
            // Generate change type analysis
            const hasBreakingChanges = files.some(f => f.deletions > f.additions * 2);
            const isRefactor = files.filter(f => f.changes > 50).length > files.length / 2;
            const isBugFix = pr.title.toLowerCase().includes('fix') || pr.title.toLowerCase().includes('bug');
            const isFeature = pr.title.toLowerCase().includes('feat') || pr.title.toLowerCase().includes('add');
            
            let changeType = 'üìù General Changes';
            if (isBugFix) changeType = 'üêõ Bug Fix';
            else if (isFeature) changeType = '‚ú® New Feature';
            else if (isRefactor) changeType = 'üîÑ Refactoring';
            else if (hasBreakingChanges) changeType = '‚ö†Ô∏è Potential Breaking Changes';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `## üìñ PR Explanation

            ### Overview
            **${pr.title}**
            
            **Change Type**: ${changeType}
            **Scope**: ${files.length} files (+${pr.additions}/-${pr.deletions} lines)

            ### Files Changed
            ${filesSummary}
            ${files.length > 15 ? `\n*...and ${files.length - 15} more files*` : ''}

            ### Change Categories
            ${categoryBreakdown || '- General changes'}

            ### Impact Analysis
            | Metric | Value | Impact |
            |--------|-------|--------|
            | Files Changed | ${files.length} | ${files.length > 10 ? '‚ö†Ô∏è Large' : files.length > 5 ? 'üìä Medium' : '‚úÖ Small'} |
            | Lines Added | +${pr.additions} | ${pr.additions > 500 ? '‚ö†Ô∏è Many' : '‚úÖ Normal'} |
            | Lines Removed | -${pr.deletions} | ${pr.deletions > 200 ? 'üìä Significant' : '‚úÖ Normal'} |
            | Test Changes | ${categories.tests.length} | ${categories.tests.length > 0 ? '‚úÖ Includes tests' : '‚ö†Ô∏è No test changes'} |

            For more detailed AI-powered explanations, use \`@copilot\` to ask questions about specific changes.

            ---
            *Explain Agent (GitHub Copilot)*`
            });
            
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });
